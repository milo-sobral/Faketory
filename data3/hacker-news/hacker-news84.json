{"id": "", "paragraph": "This doesn\u2019t need to be just about the language itself, but the whole experience of developing with it, e.g., tooling, error messages, documentation, editor integration, &c.; as simple as \u201cAvoid making me press Shift\u201d or as involved as specific problems with existing tools and what you wish they did better. I\u2019d also welcome examples of tools that do things particularly well!So far I\u2019ve had/implemented a few general ideas:1. Making whitespace-sensitive syntax, like in Python & Haskell, optional syntactic sugar for explicit brackets & separators. It can also be turned off entirely, if e.g. you work with a screenreader and prefer it not need to speak all the indentation.2. Striking a balance between concision and avoiding excessive punctuation-based syntax. I\u2019ve also tried to make sure that visually similar characters have clearly distinct functions, so it\u2019s less likely to mix them up\u2014or if they are typo\u2019d, at least the compiler should reliably detect this and produce a useful diagnostic.3. Working on integration with existing editors (through the Language Server Protocol, an Emacs mode, &c.), so ideally you can continue to use the editor you\u2019re comfortable with that supports your setup.4. Allowing the interactive mode (sort of a souped-up REPL) to be customised to support screenreaders, colour settings for colourblind people, adapting gracefully to large fonts, and so on.I\u2019m certain there are plenty of things I\u2019m still missing, though! So I\u2019d really appreciate any help, personal stories, or links to the work of similar initiatives (like Accessible Scala) that you can offer. Thank you!- Avoids the use of gratuituous special characters: (a b c)- use-dashes-in-symbol-names-instead-of-underline-so-its-easier-to-type (you can still use underlines or most any special character, but we like to keep it simple and easy).- has a simple prefix syntax, that makes it easier to read and understand complex expressions: (loop (print (read (eval))) So no risk of confusing special characters or syntax: the meaning is clearly labelled by the first symbol of each expression!- is not whitespace-sensitive, how can you see the size of whitespaces when you're blind?- includes a reader and a pretty printer, so the code can be processed and formated automatically easily for either sighted or blind programmers.- time-sharing was invented for the lisp REPL by the authors of lisp!- as a good integration with emacs, which itself has a good integration with various tools such as screen readers, vocal commands, etc, and it's fully customizable.http://cliki.net/\nhttp://common-lisp.net/\nhttps://en.wikipedia.org/wiki/Common_Lisp\nreply\n\nBracket loop bracket print bracket eval bracket read bracket bracket bracket bracket?The key thing I think is balancing and shifting parens.On the other hand I think being able to modify the syntax structurally is a big advantage.Going back to the topic of the OP I think a useful thing is putting functions after their arguments, and optimising to have single arguments or most non-main arguments being typically small. For example something more like\nreply\n\nA screen reader need not literally read what\u2019s on screen. It typically doesn\u2019t with prose, where punctuation isn\u2019t spoken, but affects timing and intonation, and abbreviations often are expanded (iOS speaks \u201cDr. John St.\u201d as \u201cDoctor John Street\u201d, for example, but \u201cSt. John Dr.\u201d as \u201cSaint John dee-ar\u201d. MacinTalk used to know that \u2018Dr\u2019 means \u2018Drive\u2019)So, it need not do that here, and could say\u201ccall read, eval it, print the result, and call loop on print\u2019s output\u201d, using intonation or voice to indicate the difference between content read from the screen and text describing it.Farfetched? Maybe, but take a look at what screen readers do with html.A screen reader that knows lisp semantics could go even further, and replace loop by repeat forever or something like it.\nreply\n\nThis seems more reasonable but how do you write the second example? Like \u201cwith foo opened as standard output, print x; also print y\u201d?There are reasonably large semantic differences in such cases and many programming languages, including lisp, express them with subtle hard-to-pronounce differences in indentation or parenthising of expressions.\nreply\n\n\nreply\n\nIt would say \"left paren\" and \"right paren.\" It's not terribly hard to keep a\nstack in your head of how many close parens you're expecting in some context.\nManually managing brackets in long or deeply nested forms (in any language) is\na pain whether you can see or not. As you said, pseudo-structural editing is a\nbig advantage.> (I think writing these on a single line makes them written more like they\n  might be spoken)Screen readers can announce indentation levels.\nreply\n\nCan't indentation be handled by the IDE as having a meaning like \"root class declaration\", \"function declaration\", \"nested block 1\", \"nested block 2\"? Indentation has meaning and meaning can be converted. Even Xcode seems to be context aware as I can choose where certain code block shortcuts can or can't be executed. \"This is a function\", \"This is a class\", \"This is a function in a class\", \"This is the root level\", \"This is a block one deep inside a function inside a class\".\nreply\n\n\nreply\n\nYou end up with \u201chacks\u201d to color your code vs a real parser to compile the code.\nreply\n\n\nreply\n\n\nreply\n\n\nreply\n\n\nreply\n\n\nreply\n\n(I suppose it would not be impossible for a programming language to have 3d layout projected onto the 2d screen, but I'm not aware of any mainstream languages that do this. Significant whitespace is fairly common of course and nonsignificant indentation is more common still)\nreply\n\n\nreply\n\n\nreply\n\nGit commands have dashes: git cherry-pick.Lots of hits with this: echo /usr/bin/-\nreply\n\n\nreply\n\nFrom what I understand, every project he works on has strict formatting requirements (can't commit until the linter passes, etc.) and his screen reader is programming language aware.Although, to be honest, I feel that the thing he relies on most is his rather amazing ability to remember most of the exact contents of whatever file he's working on.\nreply\n\n\nreply\n\n\nreply\n\n\nreply\n\nhttps://tvraman.github.io/emacspeak/manual/Emacspeak-And-Sof...\nreply\n\nI would appreciate terseness. For example, I love how in JS, I can do this:```\nvar cat = whichCat();\nvar catPosts = posts.filter(post => post.cat === cat);\n```Whereas in PHP, I have to do this:```\n$cat = whichCat();\n$catPosts = array_filter($posts, function($post) use ($cat) {\n    return $post->cat === $cat;\n});\n```So much extra typing.DISCLAIMER: didn\u2019t test this code so chance of typo is 99%.\nreply\n\nhttps://github.com/melling/ErgonomicNotes/blob/master/progra...\nreply\n\n\nreply\n\n\nreply\n\n\nreply\n\n\nreply\n\nIf you don\u2019t know the symbol at all, though, that could definitely make things more challenging to learn, since then the notation is (even more) arbitrary. A lot of programming languages\u2019 symbol choices are visually mnemonic: Perl has \u201c$\u201d for scalars, \u201c@\u201d for arrays, and \u201c%\u201d for hashes because dollar-sign looks like S for scalar, at-sign looks like A for array, and percent-sign looks like a pair of things (a key and a value), but there\u2019s nothing about these symbols semantically or in their pronunciation that suggests their Perl meanings.\nreply\n\n\nreply\n\nShouldn't you be researching how they code now and then work from there? I actually feel like current way of coding using text works very well for blind people.\nreply\n\n\nreply\n\n\nreply\n\nIt seems that their needs would vary. One thing you could do is try to an interface to test it yourself.I tried to write and edit a document once using just voice commands. (Let's say someone has carpal tunnel and needs to use voice commands). It was eye opening. I realized how much more frustrating it is to go back and try to delete or fix something than anything else. And if the software didn't recognize an unusual word, it was really hard.Dragon dictate -- the software I used -- had already learned a lot of this over the years, and there were many commands for changing that, or deleting up to a point. The hard part was moving the cursor to exactly one spot and then talking in a new word.Anyway, if you tried something like that you would learn a lot.Imagine if you are blind folded, and have to hear the program and then have to keep it all in memory. Well, that is a lot to keep in your working memory. I would want some kind of canonical \"view\" to always get to in order to find my way around.I am glad you are working on this.\nreply\n\nI've tried that as well. It was very frustrating. I used the Windows speech-to-text features.Programming code is made to be typed and read. If you can't do either of those reliably, you'll be simulating that you can, which sort of by definition can't work well, because if you could simulate being able to write well, then you wouldn't even call that a disability, you'd just be different.What I'm getting at is that the problem is simulation. Ideally, there would be a way to program by voice (or with a mouse, etc). Not program by typing code with voice, but find a way to describe a program (i.e. program) via voice. A voice-centric toolkit. I hope I'm not being too vague.What we have now is such a typing-centric development world that we don't even think about all the other possiblities. Isn't the modern laptop just a really fancy version of a 100 year old typewriter?I think Bret Victor would have a lot to say about this [0].[0] http://worrydream.com/#!/TheFutureOfProgramming\nreply\n\n\"Go back 3 words and delete this word\". \"Replace the current word with 'foo'\". \"Select the current paragraph and move it down 1 paragraph\".Changing modes would likely be an issue. A safe word might not be the best solution. I guess a hardware button would be the best option.\nreply\n\nhttps://groups.google.com/forum/#!forum/blind-dev-works(I am seriously visually impaired, but not blind. I know a little HTML and CSS and I have a part-time position with the spiffy title of Webmaster, but I'm not really a programmer.)\nreply\n\nI have previously attempted to program blind and reported some of my experiences[2].[1]: https://en.wikipedia.org/wiki/ColorForth[2]: https://news.ycombinator.com/item?id=9284567\nreply\n\nTo this end I've been making plugins for Vim and WeeChat, and a script for sway:https://github.com/SirCmpwn/vimspeakhttps://git.sr.ht/~sircmpwn/dotfiles/tree/master/.weechat/py...https://git.sr.ht/~sircmpwn/dotfiles/tree/master/bin/swaytal...If you or someone you know would find these useful, please reach out so I can learn more about your needs.[0] https://swaywm.org\nreply\n\n\nreply\n\nExplicit delimiters also have an advantage for keyboard navigation, enabling some degree of structural (by-block) movement. I prefer not to use a mouse/trackpad if possible\u2014my main editor is Emacs in a terminal\u2014and I know some people who have trouble using pointing devices or just don\u2019t like switching between keyboard & pointer.\nreply\n\n\nreply\n\n\nreply\n\nProbably the simplest good example, gives rules for translating between styles\nreply\n\n- https://www.youtube.com/watch?v=cVaDY0ChvOQ\nreply\n\nI'd say from a programming language point of view, having keywords that are short (single word would be ideal) and phonetically distinct is really important.One python programmer I watched on Youtube made his own vocabulary of strange sounds that he trained his software to recognise and translate to real keywords.\nreply\n\nhttps://www.youtube.com/watch?v=8SkdfdXWYaI\nreply\n\nhttps://github.com/melling/ErgonomicNotes/blob/master/progra...\nreply\n\n\nreply\n\nInteresting question. A few years ago, I worked with a blind mathematician. I was an undergraduate T.A. and he was the main T.A. of the course. He used the screen reader a lot. In particular, he has the list of exercise in LaTeX. We read aloud the grades of the students and he wrote them in the Excel form.I don't remember him using a programming language (excluding LaTeX). The indentation looks like a difficult problem, even if the language has explicit brackets. Does the screen reader say \"Tab Tab print ten semicolon\"? Does it ignore the indentation? Spaces vs tabs? ...Do you have some group of blind programmers that you can ask about their current setup?\nreply\n\n\nreply\n\nAnother bonus to this approach is that it enforces a style guide. Overly complicated and nested programs become more difficult to understand, and excessive nesting becomes literally incomprehensible as it spirals out of the human hearing range.I wonder if you could also use different voices for different things. Code could be read in a masculine tone, code blocks in a feminine tone, inline strings with an Australian accent.\nreply\n\ne.g:\nreply\n\nhttps://github.com/derekriemer/nvda-indentone\nreply\n\n\nreply\n\n\nreply\n\nhttps://www.scala-lang.org/blog/2018/06/14/accessible-scala....\nreply\n\nThat seems like the best way to support disabled programmers, as it gives them the flexibility to make whatever syntax works for them, as long as your core AST is simple enough.\nreply\n\n\nreply\n\nTake a look at Quorum, a \"programming language which is designed to be accessible to individuals with disabilities and is widely used in schools for the blind\".[0] - https://quorumlanguage.com/[1] - https://www.youtube.com/watch?v=X29BuzGHlBs\nreply\n\n\nreply\n\n\nreply\n\nNow compare:\nreply\n\nIt's much easier for me to interpret JavaScript or PHP method chaining. I find myself struggling when I can't use an ORM.\nreply\n\n\nreply\n\nMaybe it's the way I was taught.\nreply\n\n\nreply\n\n\nreply\n\nConsidering that dyslexia is a reading disorder, I suppose that the programming language can be really important.\nreply\n\nI guess you could also require the edit distance between identifiers to be at least X, but I expect that to be wildly impopular, if only because its effect on identifiers in libraries.\nreply\n\nI've been thinking about this alot lately because I've been wondering how I could get better at programming while driving on my daily commute.\nreply\n\nPlease don't do this. The last thing the world needs is another distracted driver.\nreply\n\nhttps://en.wikipedia.org/wiki/Refreshable_braille_display\nreply\n\n\nreply\n\n\nreply\n\n\nreply\n\n\nreply\n\n\nreply\n\nThere's tons of IDEs that make developers better at coding, with things like automatic syntax checking, refactoring, inline debugging, autocomplete, etc. Would it make more sense to develop a developing environment that makes disabled developers better at coding, with whatever features would make their experience better?It would probably be easier to get a disabled developer to use your editor than to get a disabled developer to use your language. From what I can gather, it's hard enough to get employment as it is for them (maybe they can only work remote, or maybe they can be physically in the office but they're blind). I'm not sure if they have the luxury of being able to choose what language they get to use. But I'm sure their employers would allow them to use the IDE & tooling that works for them so long as they output code that fits the company stack.\nreply\n\nDisclaimer: these are my thoughts, and should not be generalized to all blind programmers.First, let\u2019s start with the supporting technologies, mainly screen readers.  The most popular screen reader is Jaws for Windows (expensive product), followed by Non Visual Desktop Access (opensource product), distantly followed by VoiceOver (your only choice for Apple products).  My main day-to-day driver is NVDA, but I also use Jaws for my job.  I do not use a braille display.  The IDEs that I use are Visual Studio (C# development) and Visual Studio Code (Python and Javascript development).Indentation-sensitive languages such as Python really aren\u2019t that difficult to use, once you figure out how to get your screen reader to announce indentation levels.  Typically, the screen reader only announces indentation changes when there is a difference from the line that you are coming from.  A sample Python function would read as follows as I press the down-arrow to read line-by-line (note that I\u2019m purposely not putting in line breaks, since an audio-based screen reader is inherently serial):\u201cdef foo left paren right paren colon, four spaces number say hello world, print left paren quote hello world quote right paren, zero spaces blank\u201dInterestingly, I find lisp one of the most difficult languages, since there are so many parentheses, and it\u2019s difficult to keep track of what nesting you are in.Screen readers are not programming language aware.  It\u2019s all text to them.Using pitch to communicate information is more distracting than anything.  Imagine that you were having a conversation with someone, and every few words, their voice completely changed.  It makes understanding the meaning of what they are saying more difficult, since your brain is too busy going \u201chey, something changed!\u201dSome additional reading that I recommend is \u201cAn Exploratory Study of Blind Software Developers\u201d, which can be found at https://ciigar.csc.ncsu.edu/files/bib//Mealin2012-BlindDevel....  That identifies some programming challenges that participants face, as well as some of the areas that blind programmers self-report as excelling in.  Full disclosure, I was the primary researcher on that study.Finally, a mini soapbox rant: something that I see quite often is people doing blindness \u201csimulations\u201d for a short period of time.  They then write up their experience, which isn\u2019t a bad thing, but then present their work as \u201cI found this hard, so all blind people must find this hard.\u201d  Identifying when a task has a large learning curve is important, but also do keep in mind that people who are blind have significant experience in identifying ways to overcome potential accessibility problems.\nreply\n\nObviously, inherent to programming is diving deep into chained function calls and managing all those levels in abstraction in one's mind. However, for someone with a limited working memory for whatever reason--adhd, depression, chronic pain, anxiety, headaches and more--having this minimized as much as possible would be a lifesaver.\nreply\n\nThis was just a fun experiment - I'm not blind or visually impaired - but I imagine that the concept could useful for programmers who depend on screen readers. It could be simplified as well; e.g., adjust the pitch or timbre of the voice depending on the nesting level of code.\nreply\n\nI feel like the English like syntax and use of keywords instead of symbols would be very beneficial for people with disabilities.I guess python is in a similar vein, but ruby doesn\u2019t rely on white space for its blocks, which I think is a real plus.\nreply\n\n1. Indentation: Pretty much a solved problem at this point. If I were reading Python code line-by-line, my editor might speak something like (not sure if my newlines will make it, but imagine them where they should be):\ndef hello(world):\n4 spaces print(\"Hello, world.\")\n4 spaces 1 tab 4 spaces print(\"What was I thinking when I indented this line?\")So I wouldn't worry too much about that. I've never had issues with an indentation-based language, and anyone blind who does likely just needs to change their tooling a bit. This is usually just a checkbox in the screen reader settings, so doesn't even usually require an editor/IDE change.2. Avoid crazy symbols. Scala gave me some grief with this, with every library author having method names like %^&@^$# because I assume that set of symbols looks like performHttpRequest(...) in some visual way. I exaggerate a bit. Only a bit. Note that operator overloading is fine, at least  from an accessibility perspective. It's when people decide that a series of connected punctuation symbols evokes the idea of making an HTTP request or opening an Option that I start to get annoyed.3. Create good command line tooling. Rust has this nailed. I like how Rust's own installer just uses rustup under the hood, or at least I think it does, and every blog post advertising a new component also includes the rustup incantations to grab it. I assume the editor interfaces are as nice or nearly so. I guess the takeaway is, package your language installation tooling in a library so you can invoke it from the CLI, editor plugins, etc.4. Put error messages at the bottom of stacktraces rather than the top. Python does this right, and everyone else gets it wrong[1]. Say you're running a compiler from your command line. You get an error, and your cursor lands on the input area, ready for a new command. As a screen reader user, you discover that error by entering your window's review mode and moving up. With JavaScript, Rust, and just about everything else, I have to arrow through the callstack in reverse as I move up the screen to the line containing the error. Python puts this error last, near the input cursor, so all you're doing is arrowing up a couple lines. It's a few seconds per error, but can add up immensely over the course of a day. NPM, infuriatingly, shows the error, followed by disclaimer text that the error isn't in NPM, then barfs up an NPM error just to confuse things. So any JS package I use that uses NPM for its scripting requires arrowing back through 2 stacktraces to find the original error. It's enough to drive me to drink.I can probably come up with more, but I haven't finished my coffee yet. Perhaps that's a good thing...1. Right and wrong are of course subjective. This is just one blind dude's opinion, take it for what it's worth.\nreply\n\nFor example, some languages will let you use \u03bb instead of lambda. Or when trying to define the logistic function, I sometimes find myself writingSometimes this sort of thing lets code correspond almost exactly to the notation in papers. It is a minor aesthetic improvement, but if it breaks screen readers and other tools I'd rather just write out \"sigma\" or \"lambda\".\nreply\n\n\nreply\n\n\nreply\n\n\nreply\n\n\nreply\n\nAs for #3, my compiler is intended to be all-in-one: there\u2019s a single executable that acts as a front-end for an internal library, which handles everything: compilation, syntax highlighting, dependency management, documentation generation, you name it. So all the language tooling should just work in a consistent way.\nreply\n\n\nreply\n\n\nreply\n\n\nreply\n\n\nreply\n\nThat shouldn't matter with an IDE or plugin.  If static analysis can identify the blocks -- and it has to! -- the screen reader can just read it as if it had your preferred block notation rather than noting the whitespace.\nreply\n\n\nreply\n\n\nreply\n\n\nreply\n\n\nreply\n\nI would suggest you try it yourself, and download JAWS and write out some simple Hello World and figure out the challenges you face and then get in touch with disabled programmers and advocates.\nreply\n\n\nreply\n\n\nreply\n\nI can't really think of anything that would greatly enhance my current Linux/tmux/emacs setup.\nreply\n\n\nreply\n\n\nreply\n\n\nreply\n\n3. If you make a GUI framework, use native controls. Screen readers aren't magical pieces of software that do their things using arcane spells, to read anything, they actually need to get the information to read. To do this, they use operating system APIs. When an application uses native controls, it exposes all the needed information through those APIs and a screen reader can get it easily. If an application has it's own GUI toolkit, it's own representation of controls that doesn't correspond to the OS notions of a control and draws on the screen directly, the screen reader doesn't know anything at all. This is the case with i.e. GTK on windows. For a long time, this was also the case with Flash, Java and QT. \n4. screen reader users generally prefer words over symbols (controversial, some might disagree). Symbols are nice for sighted users because they take less space on the screen and are faster to read, but for screen reader users they are not. \nLua's \"if a less than 1 then print quote this is a test quote end\" reads much more naturally than go's \"if a less than 1 left brace fmt dot print l n left paren quote this is a test quote right paren right brace\". There's a reason why blind programmers like lua and ruby.\n5. Very hard to do right, but one of the most annoying thing for me is to deal with various messages in the console. If it's a web table, you can do two columns, timestamp and message, and a blind user will know it's a table and be able to navigate only in the second column. If it's console output, you can separate them visually, sighted users will just glance over the timestamps but blind users actually need to hear them before hearing the message. Imagine you need to listen through \"two tousant eighteen colon eleven colon zero nine seven colon fourty five colon three comma 7520, /cmd/frontend/main.go:19: server started\" before each message instead of just \"server started\". That's the sad reality for most blind people dealing with logs and messages that contain long paths etc. I don't know if that can even be done right without hiding the info alltogether, as it's not possible for a blind person to navigate a table in the console, but this is something that should be taken into consideration.\nreply\n\nA more accessible and portable language is one that eliminates overloading and redundancy.  Everything in the syntax and expression is deliberate and its not open to various subjective forms of reasoning.Eliminate white space as syntax.  Beauty is subjective, but it isn't necessarily accessible, and it certainly isn't automatically simple.  White space as syntax is common in nearly all languages.  Even in Java there is white space to separate keywords.  White space elimination allows any manner of visual expression and beautification of the language.  It also prevents corruption of the code over the wire due to reformatting of corrupting user-agents and OSes that have different line endings.  One form of corruption is when a token is shifted, due to different reasoning of line termination, onto a previous line terminated by a line comment.Eliminate operator overloading.  In JavaScript the plus character could mean addition, or string concatenation, or type coercion, or other weird things.  The plus character could be a single character operator or the dreaded ++ which could mean post-increment or pre-increment.  In JavaScript the forward slash could mean division or regular expression.  For a blind person reading the code as characters or tokens this kind of overloading is unnecessarily confusing bullshit.Conversely JavaScript has two different syntax forms for assignment.  The common form of assigning is using a single equals character.  In object literals a colon is used for assignment.  This is stupid and looks completely different from the algebra on which equivalent logic is based.  Make the colon character the character of all assignment.  This leaves the single equals character free for comparisons.  If the language imposes a strong/static type system there will be no need for double or triple character comparison operators.I would invoke a strong/static type system.  This allows error detection very early which reduces testing time and jumping between application environments.I would design the language in such a way that it encourages code in structures.  It is easier to follow code when it reads similar to its flow control at execution time.  In this regard I would write the syntax such that it encourages containment, nesting, function as organizational models that can be nested, and design everything around primitive data structures.I am not a fan of OOP programming where the application is easier to write/expand than to debug or read.  OOP constructs tend to be convention heavy, keyword heavy, and syntax heavy.  Functional/structured languages allow the deliberate organization of its pieces to do much of the heavy lifting as opposed to referenced or logical organizations.Don't worry about superficial tooling support.  Solve the language design problems, the hard problems first.  The helpful tooling bits will be easy if you have nailed the hard decisions and produced something with clarity, simplicity, and deliberation.\nreply\n\n> Don't worry about superficial tooling support. Solve the language design\n  problems, the hard problems first.That's mostly what people have been doing for the last most-of-a-century, and\nit's led to a lot of software being much harder to use for disabled people.\nreply\n\nThe classic example is wheel chair ramps. Who benefits from those? People who have bad knees, people with strollers, people with heavy roller bags. The ramp was installed for wheelchairs but everybody benefits. If the solution were limited only to wheelchairs almost nobody would use it. It would just be in the way and be more of a problem than a solution.If you are only solving for blindness you don\u2019t really understand accessibility and are just in the way.\nreply\n\n\nreply\n\nSpecifically regarding programming languages the primary concern is parsing, whether that parsing is from software or people reading code.As a person who has spent 10 years writing language parsers and code beautifiers the vane notions of what a language should look like are highly subjective and not incredibly beneficial.  The mechanics and syntax of a language are far more important for understanding what code says very quickly.  Like with natural written language elimination of ambiguities and redundant meanings speeds learning and reading which has second and third order consequences for the simplicity of tool design.\nreply\n\n\nreply\n\n\nreply\n\n"}